<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{block "title" .}}GProject - GitHub Issues Frontend{{end}}</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50">
    <nav class="bg-white shadow">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <a href="/" class="text-xl font-bold">GProject</a>
                </div>
                {{if .User}}
                <div class="flex items-center space-x-4">
                    <!-- SSE Connection Status Indicator -->
                    <div id="sse-status" class="flex items-center space-x-1">
                        <span id="sse-status-dot" class="h-2 w-2 rounded-full inline-block animate-pulse bg-gray-400"></span>
                        <span id="sse-status-text" class="text-xs text-gray-500">Connecting...</span>
                    </div>
                    
                    <img src="{{.User.AvatarURL}}" alt="{{.User.GitHubLogin}}" class="w-8 h-8 rounded-full">
                    <span>{{.User.GitHubLogin}}</span>
                    <a href="/logout" class="text-red-600 hover:text-red-800">Logout</a>
                </div>
                {{else}}
                <div class="flex items-center">
                    <a href="/login" class="bg-gray-900 text-white px-4 py-2 rounded flex items-center gap-2 hover:bg-gray-800">
                        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                        Login with GitHub
                    </a>
                </div>
                {{end}}
            </div>
        </div>
    </nav>
    
    <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        {{block "content" .}}{{end}}
    </main>
    
    {{if .User}}
    <script>
        // Vanilla JavaScript SSE Manager (no Alpine.js, no CSP violations)
        (function() {
            'use strict';
            
            console.log('SSE Manager initializing...');
            
            // SSE Manager state
            const state = {
                eventSource: null,
                status: 'connecting',
                statusText: 'Connecting...',
                reconnectAttempts: 0,
                maxReconnectAttempts: 5,
                reconnectDelay: 1000,
                hasConnected: false
            };
            
            // Update UI based on status
            function updateUI() {
                const statusDot = document.getElementById('sse-status-dot');
                const statusText = document.getElementById('sse-status-text');
                
                if (!statusDot || !statusText) return;
                
                // Remove all status classes
                statusDot.classList.remove('bg-green-500', 'bg-gray-400', 'bg-red-500');
                statusText.classList.remove('text-green-600', 'text-gray-500', 'text-red-600');
                
                // Add appropriate classes based on status
                switch(state.status) {
                    case 'connected':
                        statusDot.classList.add('bg-green-500');
                        statusText.classList.add('text-green-600');
                        break;
                    case 'connecting':
                        statusDot.classList.add('bg-gray-400');
                        statusText.classList.add('text-gray-500');
                        break;
                    case 'disconnected':
                    case 'error':
                        statusDot.classList.add('bg-red-500');
                        statusText.classList.add('text-red-600');
                        break;
                }
                
                statusText.textContent = state.statusText;
            }
            
            // Set status and update UI
            function setStatus(status, text) {
                state.status = status;
                state.statusText = text;
                updateUI();
            }
            
            // Disconnect SSE
            function disconnect() {
                if (state.eventSource) {
                    state.eventSource.close();
                    state.eventSource = null;
                }
                setStatus('disconnected', 'Disconnected');
            }
            
            // Handle connection errors
            function handleError() {
                if (state.reconnectAttempts >= state.maxReconnectAttempts) {
                    setStatus('error', 'Connection failed');
                    disconnect();
                    return;
                }
                
                state.reconnectAttempts++;
                setStatus('disconnected', `Reconnecting (${state.reconnectAttempts}/${state.maxReconnectAttempts})...`);
                
                setTimeout(() => {
                    connect();
                }, state.reconnectDelay);
                
                // Exponential backoff
                state.reconnectDelay = Math.min(state.reconnectDelay * 2, 30000);
            }
            
            // Connect to SSE endpoint
            function connect() {
                // Don't create duplicate connections
                if (state.eventSource && state.eventSource.readyState !== EventSource.CLOSED) {
                    return;
                }
                
                setStatus('connecting', 'Connecting...');
                state.hasConnected = false;
                
                try {
                    state.eventSource = new EventSource('/events');
                    
                    state.eventSource.onopen = () => {
                        console.log('SSE connection opened');
                        state.hasConnected = true;
                        state.reconnectAttempts = 0;
                        state.reconnectDelay = 1000;
                        setStatus('connected', 'Connected');
                    };
                    
                    state.eventSource.addEventListener('connected', (event) => {
                        console.log('Received connected event:', event.data);
                        state.hasConnected = true;
                        setStatus('connected', 'Connected');
                    });
                    
                    state.eventSource.addEventListener('error', (event) => {
                        console.log('Received error event:', event);
                        if (event.data) {
                            try {
                                const data = JSON.parse(event.data);
                                if (data.error === 'Authentication required') {
                                    setStatus('error', 'Login required');
                                    disconnect();
                                    return;
                                }
                            } catch (e) {
                                console.error('Failed to parse error data:', e);
                            }
                        }
                        handleError();
                    });
                    
                    state.eventSource.addEventListener('sync_status', (event) => {
                        console.log('Sync status update:', event.data);
                        // Handle sync status updates
                        try {
                            const data = JSON.parse(event.data);
                            // Update sync status in UI if needed
                            const syncStatusEl = document.getElementById('sync-status');
                            if (syncStatusEl && data.message) {
                                // Could update via HTMX or direct DOM manipulation
                                console.log('Sync status:', data.message);
                            }
                        } catch (e) {
                            console.error('Failed to parse sync status:', e);
                        }
                    });
                    
                    state.eventSource.addEventListener('issue_update', (event) => {
                        console.log('Issue update:', event.data);
                        // Handle issue updates - could trigger HTMX refresh
                        // For now, just log it
                    });
                    
                    state.eventSource.onerror = (error) => {
                        console.error('SSE connection error:', error);
                        
                        if (state.eventSource.readyState === EventSource.CLOSED) {
                            if (!state.hasConnected) {
                                // Connection failed immediately - likely authentication error
                                fetch('/events', {
                                    method: 'GET',
                                    headers: { 'Accept': 'text/event-stream' },
                                    credentials: 'same-origin'
                                }).then(response => {
                                    if (response.status === 401) {
                                        setStatus('error', 'Login required');
                                        disconnect();
                                    } else {
                                        handleError();
                                    }
                                }).catch(() => {
                                    handleError();
                                });
                            } else {
                                // Connection was established but then lost
                                handleError();
                            }
                        }
                    };
                    
                    // Store globally for debugging
                    window.sseManager = state;
                    
                } catch (error) {
                    console.error('Failed to create EventSource:', error);
                    handleError();
                }
            }
            
            // Initialize on DOMContentLoaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    connect();
                    
                    // Handle page visibility changes
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            disconnect();
                        } else {
                            connect();
                        }
                    });
                    
                    // Clean up on page unload
                    window.addEventListener('beforeunload', () => {
                        disconnect();
                    });
                });
            } else {
                // DOM already loaded
                connect();
                
                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        disconnect();
                    } else {
                        connect();
                    }
                });
                
                // Clean up on page unload
                window.addEventListener('beforeunload', () => {
                    disconnect();
                });
            }
        })();
    </script>
    {{end}}
</body>
</html>